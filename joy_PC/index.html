<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>PC</title>

        <!-- Babylon.js implementation -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() 
        { 
            return new BABYLON.Engine(canvas, true, 
            { 
                preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false
            }); 
        };
        var createScene = function () 
        {
            var scene = new BABYLON.Scene(engine);

            function Respawn_room($floor_texture, $wall_texture) 
            {
                for (let posez = -10; posez < 20; posez+=10) 
                {
                    for (let posex = -15; posex < 25; posex+=10) 
                    {
                        var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        floor.material = new BABYLON.StandardMaterial("Mat", scene);
                        floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        floor.material.diffuseTexture.hasAlpha = true;
                        floor.position = new BABYLON.Vector3(posex, -1, posez);
                        floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        floor.checkCollisions = true;

                        // //Ceiling
                        // var ceiling = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        // ceiling.material = new BABYLON.StandardMaterial("Mat", scene);
                        // ceiling.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        // ceiling.material.diffuseTexture.hasAlpha = true;
                        // ceiling.position = new BABYLON.Vector3(posex, 9, posez);
                        // ceiling.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        // ceiling.checkCollisions = true;
                    }
                }

                for (let posez = -10; posez < 20; posez+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(-20, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posez = -10; posez < 20; posez+=20) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(20, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = -15; posex < 25; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 15);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -15);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

            }

            function Main_hall($floor_texture, $wall_texture) 
            {
                for (let posez = -10; posez < 20; posez+=10) 
                {
                    for (let posex = 45; posex < 75; posex+=10) 
                    {
                        var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        floor.material = new BABYLON.StandardMaterial("Mat", scene);
                        floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        floor.material.diffuseTexture.hasAlpha = true;
                        floor.position = new BABYLON.Vector3(posex, -1, posez);
                        floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        floor.checkCollisions = true;
                    }
                }

                for (let posez = -10; posez < 20; posez+=20) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(40, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(70, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 45; posex < 75; posex+=20) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 15);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -15);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                }

            }

            function Corridors($floor_texture, $wall_texture) 
            {
                for (let posex = 25; posex < 45; posex+=10) 
                {
                    var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    floor.material = new BABYLON.StandardMaterial("Mat", scene);
                    floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                    floor.material.diffuseTexture.hasAlpha = true;
                    floor.position = new BABYLON.Vector3(posex, -1, 0);
                    floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    floor.checkCollisions = true;
                }

                for (let posex = 25; posex < 45; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 5);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -5);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                // Main_hall<->Text_room
                var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                floor.material = new BABYLON.StandardMaterial("Mat", scene);
                floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                floor.material.diffuseTexture.hasAlpha = true;
                floor.position = new BABYLON.Vector3(75, -1, 0);
                floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                floor.checkCollisions = true;

                for (let posex = 75; posex < 85; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 5);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -5);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                // Main_hall<->Media_room/Main_hall<->Presentation_room
                var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                floor.material = new BABYLON.StandardMaterial("Mat", scene);
                floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                floor.material.diffuseTexture.hasAlpha = true;
                floor.position = new BABYLON.Vector3(55, -1, -20);
                floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                floor.checkCollisions = true;

                var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                floor.material = new BABYLON.StandardMaterial("Mat", scene);
                floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                floor.material.diffuseTexture.hasAlpha = true;
                floor.position = new BABYLON.Vector3(55, -1, 20);
                floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                floor.checkCollisions = true;

                for (let posex = 50; posex < 60; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -20);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 20);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 60; posex < 70; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -20);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 20);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

            }

            function Text_room($floor_texture, $wall_texture) 
            {
                for (let posez = -20; posez < 30; posez+=10) 
                {
                    for (let posex = 85; posex < 105; posex+=10) 
                    {
                        var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        floor.material = new BABYLON.StandardMaterial("Mat", scene);
                        floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        floor.material.diffuseTexture.hasAlpha = true;
                        floor.position = new BABYLON.Vector3(posex, -1, posez);
                        floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        floor.checkCollisions = true;
                    }
                }

                for (let posez = -20; posez < 0; posez+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(80, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posez = 10; posez < 30; posez+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(80, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posez = -20; posez < 30; posez+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(100, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 85; posex < 105; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 25);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -25);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                // Text 
                var text = BABYLON.Mesh.CreateBox("crate", 0, scene);
                text.material = new BABYLON.StandardMaterial("Mat", scene);
                text.material.diffuseTexture = new BABYLON.Texture("textures/walls/TEXT.png", scene);
                text.material.diffuseTexture.hasAlpha = true;
                text.position = new BABYLON.Vector3(80.1, 4, 15);
                text.scaling = new BABYLON.Vector3(10, 0.1, 10);
                text.rotation.z = Math.PI / 2;
                text.checkCollisions = true;

                var text = BABYLON.Mesh.CreateBox("crate", 0, scene);
                text.material = new BABYLON.StandardMaterial("Mat", scene);
                text.material.diffuseTexture = new BABYLON.Texture("textures/walls/TEXT.png", scene);
                text.material.diffuseTexture.hasAlpha = true;
                text.position = new BABYLON.Vector3(80.1, 4, -15);
                text.scaling = new BABYLON.Vector3(10, 0.1, 10);
                text.rotation.z = Math.PI / 2;
                text.checkCollisions = true;

                var text = BABYLON.Mesh.CreateBox("crate", 0, scene);
                text.material = new BABYLON.StandardMaterial("Mat", scene);
                text.material.diffuseTexture = new BABYLON.Texture("textures/walls/TEXT.png", scene);
                text.material.diffuseTexture.hasAlpha = true;
                text.position = new BABYLON.Vector3(99.9, 4, -5);
                text.scaling = new BABYLON.Vector3(10, 0.1, 10);
                text.rotation.x = Math.PI / -1;
                text.rotation.z = Math.PI / 2;
                text.checkCollisions = true;

                var text = BABYLON.Mesh.CreateBox("crate", 0, scene);
                text.material = new BABYLON.StandardMaterial("Mat", scene);
                text.material.diffuseTexture = new BABYLON.Texture("textures/walls/TEXT.png", scene);
                text.material.diffuseTexture.hasAlpha = true;
                text.position = new BABYLON.Vector3(99.9, 4, 5);
                text.scaling = new BABYLON.Vector3(10, 0.1, 10);
                text.rotation.x = Math.PI / -1;
                text.rotation.z = Math.PI / 2;
                text.checkCollisions = true;

            }

            function Media_room($floor_texture, $wall_texture) 
            {
                for (let posez = -40; posez < -20; posez+=10) 
                {
                    for (let posex = 35; posex < 65; posex+=10) 
                    {
                        var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        floor.material = new BABYLON.StandardMaterial("Mat", scene);
                        floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        floor.material.diffuseTexture.hasAlpha = true;
                        floor.position = new BABYLON.Vector3(posex, -1, posez);
                        floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        floor.checkCollisions = true;
                    }

                    for (let posex = 35; posex < 65; posex+=10) 
                    {
                        var ceiling = BABYLON.Mesh.CreateBox("crate", 0, scene);
                        ceiling.material = new BABYLON.StandardMaterial("Mat", scene);
                        ceiling.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                        ceiling.material.diffuseTexture.hasAlpha = true;
                        ceiling.position = new BABYLON.Vector3(posex, 9, posez);
                        ceiling.scaling = new BABYLON.Vector3(10, 0.1, 10);
                        ceiling.checkCollisions = true;
                    }
                }

                for (let posez = -40; posez < -20; posez+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(60, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(30, 4, posez);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 35; posex < 65; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -45);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 35; posex < 55; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, -25);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                //Film
                var screen = 
                {
                    height: 10, 
                    width: 20, 
                };
                var screenOpts = BABYLON.MeshBuilder.CreatePlane("plane", screen, scene);
                screenOpts.position = new BABYLON.Vector3(30.1, 4, -35);
                screenOpts.rotation.y = Math.PI / -2;
                var screenMat = new BABYLON.StandardMaterial("m", scene);
                var screenTex = new BABYLON.VideoTexture("vidtex","films/wixapol.mp4", scene);
                screenMat.diffuseTexture = screenTex;
                screenMat.emissiveColor = new BABYLON.Color3.White();
                screenOpts.material = screenMat;

                //Barrier 
                var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                wall.visibility = -1;
                wall.material = new BABYLON.StandardMaterial("Mat", scene);
                wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                wall.material.diffuseTexture.hasAlpha = false;
                wall.position = new BABYLON.Vector3(40, 4, -35);
                wall.scaling = new BABYLON.Vector3(10, 0.1, 20);
                wall.rotation.z = Math.PI / 2;
                wall.checkCollisions = true;

                //Music 
                var sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
                sphereMat.diffuseColor = BABYLON.Color3.Red();
                sphereMat.backFaceCulling = false;
                sphereMat.alpha = 0;
                var sphereMusic1 = BABYLON.Mesh.CreateSphere("musicsphere", 100, 20, scene);
                sphereMusic1.material = sphereMat;
                sphereMusic1.position = new BABYLON.Vector3(50, 3, -35);
                var music1 = new BABYLON.Sound("music", "sounds/wixapol.mp3", scene, 
                null, { loop: true, autoplay: true, maxDistance: 15, useCustomAttenuation: true });
                music1.attachToMesh(sphereMusic1);

            }

            function Presentation_room($floor_texture, $wall_texture) 
            {
                for (let posex = 45; posex < 75; posex+=10) 
                {
                    var floor = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    floor.material = new BABYLON.StandardMaterial("Mat", scene);
                    floor.material.diffuseTexture = new BABYLON.Texture($floor_texture, scene);
                    floor.material.diffuseTexture.hasAlpha = true;
                    floor.position = new BABYLON.Vector3(posex, -1, 30);
                    floor.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    floor.checkCollisions = true;
                }

                for (let posex = 45; posex < 75; posex+=10) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 35);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                for (let posex = 40; posex < 90; posex+=30) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 30);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;

                }

                for (let posex = 45; posex < 75; posex+=20) 
                {
                    var wall = BABYLON.Mesh.CreateBox("crate", 0, scene);
                    wall.material = new BABYLON.StandardMaterial("Mat", scene);
                    wall.material.diffuseTexture = new BABYLON.Texture($wall_texture, scene);
                    wall.material.diffuseTexture.hasAlpha = true;
                    wall.position = new BABYLON.Vector3(posex, 4, 25);
                    wall.scaling = new BABYLON.Vector3(10, 0.1, 10);
                    wall.rotation.y = Math.PI / 2;
                    wall.rotation.z = Math.PI / 2;
                    wall.checkCollisions = true;
                }

                var photo = BABYLON.Mesh.CreateBox("crate", 0, scene);
                photo.material = new BABYLON.StandardMaterial("Mat", scene);
                photo.material.diffuseTexture = new BABYLON.Texture("img/1.png", scene);
                photo.material.diffuseTexture.hasAlpha = true;
                photo.position = new BABYLON.Vector3(55, 4, 35);
                photo.scaling = new BABYLON.Vector3(10, 0.1, 10);
                photo.rotation.y = Math.PI / 2;
                photo.rotation.z = Math.PI / 2;
                photo.checkCollisions = true;

                var photo = BABYLON.Mesh.CreateBox("crate", 0, scene);
                photo.material = new BABYLON.StandardMaterial("Mat", scene);
                photo.material.diffuseTexture = new BABYLON.Texture("img/2.png", scene);
                photo.material.diffuseTexture.hasAlpha = true;
                photo.position = new BABYLON.Vector3(40, 4, 30);
                photo.scaling = new BABYLON.Vector3(10, 0.1, 10);
                photo.rotation.z = Math.PI / 2;
                photo.checkCollisions = true;

                var photo = BABYLON.Mesh.CreateBox("crate", 0, scene);
                photo.material = new BABYLON.StandardMaterial("Mat", scene);
                photo.material.diffuseTexture = new BABYLON.Texture("img/3.png", scene);
                photo.material.diffuseTexture.hasAlpha = true;
                photo.position = new BABYLON.Vector3(70, 4, 30);
                photo.scaling = new BABYLON.Vector3(10, 0.1, 10);
                photo.rotation.x = Math.PI / -1;
                photo.rotation.z = Math.PI / 2;
                photo.checkCollisions = true;

            }

            // Mapmakers
            Respawn_room("textures/floors/carpet.png", "textures/walls/whitebricks.png");
            Corridors("textures/floors/carpet.png", "textures/walls/whitebricks.png");
            Main_hall("textures/floors/carpet.png", "textures/walls/whitebricks.png");
            Text_room("textures/floors/carpet.png", "textures/walls/whitebricks.png");
            Media_room("textures/floors/media_floor.png", "textures/walls/media_wall.png");
            Presentation_room("textures/floors/carpet.png", "textures/walls/whitebricks.png");

            // GLB loader
            // var load = new BABYLON.SceneLoader.ImportMesh("", "models/","smth.glb",scene);

            var table = new BABYLON.SceneLoader.ImportMesh("", "models/", "table.glb", scene, 
                function (newLoad) {
                    for (table in newLoad){
                    newLoad[table].scaling = new BABYLON.Vector3(0.25, 0.23, 0.25);
                    newLoad[table].position = new BABYLON.Vector3(10, 1.3, 17.5);
                    newLoad[table].checkCollisions = true;
                }});

            var table = new BABYLON.SceneLoader.ImportMesh("", "models/", "table.glb", scene, 
                function (newLoad) {
                    for (table in newLoad){
                    newLoad[table].scaling = new BABYLON.Vector3(0.25, 0.23, 0.25);
                    newLoad[table].position = new BABYLON.Vector3(10, 1.3, -17.5);
                    newLoad[table].checkCollisions = true;
                }});

            var sofa = new BABYLON.SceneLoader.ImportMesh("", "models/", "sofa.glb", scene, 
                function (newLoad) {
                    for (sofa in newLoad){
                    newLoad[sofa].scaling = new BABYLON.Vector3(2, 2, 2);
                    newLoad[sofa].position = new BABYLON.Vector3(-58, -0.3, 35);
                    newLoad[sofa].rotation.y = Math.PI / 2;
                    newLoad[sofa].checkCollisions = false;
                }});

            var column = new BABYLON.SceneLoader.ImportMesh("", "models/", "column.glb", scene, 
                function (newLoad) {
                    for (column in newLoad){
                    newLoad[column].scaling = new BABYLON.Vector3(1, 1.2, 1);
                    newLoad[column].position = new BABYLON.Vector3(45, -0.3, 5);
                    newLoad[column].rotation = new BABYLON.Vector3(0, 0, 0);
                    newLoad[column].checkCollisions = true;
                }});

            var column = new BABYLON.SceneLoader.ImportMesh("", "models/", "column.glb", scene, 
                function (newLoad) {
                    for (column in newLoad){
                    newLoad[column].scaling = new BABYLON.Vector3(1, 1.2, 1);
                    newLoad[column].position = new BABYLON.Vector3(45, -0.3, -5);
                    newLoad[column].rotation = new BABYLON.Vector3(0, 0, 0);
                    newLoad[column].checkCollisions = true;
                }});

            var alien = new BABYLON.SceneLoader.ImportMesh("", "models/", "alien.glb", scene, 
                function (newLoad) {
                    for (alien in newLoad){
                    newLoad[alien].scaling = new BABYLON.Vector3(0.2, 0.2, 0.2);
                    newLoad[alien].position = new BABYLON.Vector3(55, -1, 0);
                    newLoad[alien].rotation = new BABYLON.Vector3(0, 0, 0);
                    newLoad[alien].rotation.y = Math.PI / -2;
                    newLoad[alien].checkCollisions = false;
                }});

            // True camera
            var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 2.8, 0), scene);
            camera.attachControl(canvas, true);
            camera.speed  = 0.5;
            scene.gravity = new BABYLON.Vector3(0, -1, 0);
            scene.collisionsEnabled = true;
            camera.checkCollisions = true;
            camera.applyGravity = true;
            camera.ellipsoid = new BABYLON.Vector3(1.8, 1.8, 1.8);

            // Dev camera
            // var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
            // camera.inputs.addMouseWheel();
            // camera.setTarget(BABYLON.Vector3.Zero());
            // camera.attachControl(true);

            //Lights
            var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(10, 10, -10), scene);
            light0.intensity = 0.7;
            var light1 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-10, 10, 10), scene);
            light1.intensity = 0.7;
            var light2 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(0, -1, 0), scene);
            light2.intensity = 0.3;

            //PC control adding
            //WASD moving
            camera.keysUp.push(87); 
            camera.keysDown.push(83);            
            camera.keysRight.push(68);
            camera.keysLeft.push(65);

            //Camera rotation by mouse
            var isLocked = false;
            scene.onPointerDown = function (evt) 
            {       
                if (!isLocked) 
                {
                    canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
                    if (canvas.requestPointerLock) 
                    {
                        canvas.requestPointerLock();
                    }
                }
                if (evt === 0) 
                {
                    castRay()
                }; 
            };
            var pointerlockchange = function () 
            {
                var controlEnabled = document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement || document.pointerLockElement || null;
                if (!controlEnabled) 
                {
                    isLocked = false;
                } 
                else 
                {
                    isLocked = true;
                }
            };
        
            document.addEventListener("pointerlockchange", pointerlockchange, false);
            document.addEventListener("mspointerlockchange", pointerlockchange, false);
            document.addEventListener("mozpointerlockchange", pointerlockchange, false);
            document.addEventListener("webkitpointerlockchange", pointerlockchange, false);
            
            return scene;
        }
                window.initFunction = async function() 
                {
                    var asyncEngineCreation = async function() 
                    {
                        try 
                        {
                            return createDefaultEngine();
                        } 
                        catch(e) 
                        {
                            console.log("the available createEngine function failed. Creating the default engine instead");
                            return createDefaultEngine();
                        }
                    }
                    window.engine = await asyncEngineCreation();
                    if (!engine) throw 'engine should not be null.';
                    window.scene = createScene();
                };
                initFunction().then(() => 
                {   
                    sceneToRender = scene        
                    engine.runRenderLoop(function () 
                    {
                        if (sceneToRender && sceneToRender.activeCamera) 
                        {
                            sceneToRender.render();
                        }
                    });
                });
                window.addEventListener("resize", function () 
                {
                    engine.resize();
                });
    </script>
</body>
</html>
